# [1861. Rotating the Box](https://leetcode.com/problems/rotating-the-box/description/)

이 문제는 2D 박스(상자)를 회전시키고, 중력의 영향을 받아 돌들이 아래로 떨어지는 상황을 시뮬레이션하는 문제이다.

문제의 주요 포인트는 다음과 같습니다.

1. 박스는 90도 시계방향으로 회전한다.
2. 박스 내에는 세 가지 요소가 있다:
   - '#' (돌)
   - '*' (장애물)
   - '.' (빈 공간)
3. 회전 후, 돌들은 중력의 영향을 받아 아래로 떨어지지만, 장애물은 움직이지 않는다.

## 풀이 접근 방법

1. 먼저 박스를 90도 시계방향으로 회전시킨다.
2. 회전된 박스의 각 열을 아래에서 위로 스캔하면서
   - 장애물(*)을 만나면 그 위에 있는 돌(#)들이 장애물 위에 쌓이도록 한다.
   - 빈 공간(.)을 만나면 그 위에 있는 돌들이 아래로 떨어지도록 한다.

예시를 통해 설명하겠다.

```text
입력 박스:
# . * .
# # . .

회전 후:
# #
# .
. *
. .

중력 적용 후:
. .
. #
# *
# .
```

이 문제를 해결하기 위한 코드를 살펴보자.

```java
class Solution {
    public char[][] rotateTheBox(char[][] box) {
        int m = box.length;
        int n = box[0].length;
        
        // 90도 회전
        char[][] rotated = new char[n][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rotated[j][m - 1 - i] = box[i][j];
            }
        }
        
        // 각 열에 대해 중력 적용
        for (int j = 0; j < m; j++) {
            int emptyPos = n - 1;
            for (int i = n - 1; i >= 0; i--) {
                if (rotated[i][j] == '*') {
                    emptyPos = i - 1;
                } else if (rotated[i][j] == '#') {
                    if (emptyPos > i) {
                        rotated[emptyPos][j] = '#';
                        rotated[i][j] = '.';
                        emptyPos--;
                    } else {
                        emptyPos = i - 1;
                    }
                }
            }
        }
        
        return rotated;
    }
}
```

## 코드 설명

1. **회전 단계**
   - 입력 박스의 크기가 m x n일 때, 회전된 박스는 n x m 크기가 된다.
   - 각 요소의 위치를 (i, j)에서 (j, m-1-i)로 변환하여 90도 회전을 구현한다.
2. **중력 적용 단계**
   - 각 열을 아래에서 위로 스캔한다.
   - `emptyPos` 변수는 현재 열에서 돌이 떨어질 수 있는 가장 낮은 위치를 추적합니다.
   - 장애물(*)을 만나면 그 위에만 돌이 쌓일 수 있도록 emptyPos를 조정합니다.
   - 돌(#)을 만나면 가능한 가장 낮은 위치로 이동시키고, 원래 위치는 빈 공간(.)으로 만듭니다.

이 알고리즘의 시간 복잡도는 O(mn)이며, 공간 복잡도도 O(mn)이다. 여기서 m과 n은 입력 박스의 행과 열의 수다.

이 풀이는 문제의 요구사항을 모두 만족하며, 효율적으로 작동한다. 각 단계가 명확하게 분리되어 있어 코드의 가독성도 좋다.