## [자물쇠와 열쇠](https://school.programmers.co.kr/learn/courses/30/lessons/60059)

## 문제 분석

이 문제는 2020 카카오 블라인드 공채에서 출제된 문제로, 주요 내용은 다음과 같다.

- 열쇠(key)와 자물쇠(lock)가 2차원 배열로 주어진다.
- 열쇠를 회전시키고 이동시켜 자물쇠의 모든 홈을 채워야 한다.
- 자물쇠의 모든 홈이 채워지면(모든 원소가 1이면) 자물쇠가 열린다.
- 열쇠의 돌기와 자물쇠의 돌기가 만나면 안 된다.

## 핵심 접근 방식: "홀 카운팅 + 범위 최적화"
### 1. 문제 재정의: "홀을 정확히 채우기"

``` java
int holes = 0, ln = lock.length, kn = key.length;
for (int i = 0; i < ln; i++) {
    for (int j = 0; j < ln; j++) {
        holes += lock[i][j] == 0 ? 1 : 0;
    }
}
```

**핵심 통찰**:
- 자물쇠가 열리려면 → 모든 홀(0)이 정확히 채워져야 함
- 즉, "키의 돌기로 채운 홀의 개수 = 전체 홀의 개수"여야 함
- 이를 카운터로 관리하면 매번 전체 배열을 확인할 필요 없음

### 2. 범위 최적화: "키가 어디까지 갈 수 있나?"

``` java
for (int i = -kn + 1; i < ln; i++) {
    for (int j = -kn + 1; j < ln; j++) {
```

**논리적 분석**:
**왜 `-kn + 1`부터 시작할까?**
``` 
키 크기가 3x3, 자물쇠가 5x5인 경우:
    
키 위치 (-2, 0):     키 위치 (-3, 0):
[K][K][K]           [K][K][K]
[K][K][K] [L][L]    [K][K][K] [L]
[K][K][K] [L][L]    [K][K][K] [L]
          [L][L]              [L]
          [L][L]              [L]

-2까지는 의미있음    -3부터는 자물쇠와 겹치지 않음
```
**왜 `ln`까지만 갈까?**
``` 
키 위치 (5, 0):      키 위치 (6, 0):
[L][L][L][L][L]     [L][L][L][L][L]
[L][L][L][L][L]     [L][L][L][L][L]  
[L][L][L][L][L]     [L][L][L][L][L]
[L][L][L][L][L]     [L][L][L][L][L]
[L][L][L][L][L]     [L][L][L][L][L]
[K][K][K]                       [K][K][K]
[K][K][K]                       [K][K][K]
[K][K][K]                       [K][K][K]

5부터는 자물쇠와    6부터는 의미없음
겹치지 않음
```

### 3. 충돌 검사 + 홀 카운팅

``` java
private boolean canUnlock(int[][] lock, int[][] key, int startY, int startX, int totalHoles) {
    int filledHoles = 0;
    
    for (int i = 0; i < key.length; i++) {
        for (int j = 0; j < key[i].length; j++) {
            int ny = startY + i, nx = startX + j;
            
            if (ny >= 0 && nx >= 0 && ny < lock.length && nx < lock[ny].length) {
                if (key[i][j] == 1) {
                    if (lock[ny][nx] == 1) {
                        return false;  // 돌기끼리 충돌!
                    }
                    filledHoles++;     // 홀을 채움
                }
            }
        }
    }
    
    return filledHoles == totalHoles;  // 모든 홀이 정확히 채워졌나?
}
```
**논리 흐름**:
1. **범위 체크**: 키가 자물쇠 밖으로 나가는 부분은 무시
2. **충돌 체크**: 키의 돌기(1)와 자물쇠의 돌기(1)가 만나면 즉시 실패
3. **홀 카운팅**: 키의 돌기가 자물쇠의 홀(0)을 채울 때마다 카운트
4. **완성 체크**: 채운 홀의 개수가 전체 홀 개수와 정확히 일치해야 성공

### 4. 회전 처리

``` java
for (int rotate = 0; rotate < 4; rotate++) {
    // ... 모든 위치 시도 ...
    key = rotateKey(key, kn);  // 90도 회전
}
```

**시계방향 90도 회전 공식**:
``` java
newKey[j][kn - i - 1] = key[i][j];
```

## 전체 알고리즘의 논리적 구조

``` 
1. 자물쇠의 총 홀 개수 계산
2. 홀이 0개면 이미 완성 → true 반환
3. 키를 4방향으로 회전하면서:
   a. 가능한 모든 위치에서:
      - 키와 자물쇠가 충돌하는지 확인
      - 키가 채우는 홀의 개수 계산
      - 모든 홀이 정확히 채워지면 → true 반환
4. 모든 경우를 시도했는데 안되면 → false 반환
```

## 왜 이 접근이 뛰어난가?

### 1. **수학적 정확성**

- "모든 홀이 채워져야 한다"는 조건을 정확히 수치화
- 필요충분조건을 명확히 정의

### 2. **계산 최적화**

- 불필요한 배열 확장 없음
- 의미있는 범위만 탐색
- 조기 종료로 평균 성능 향상

### 3. **메모리 효율성**

- O(N²) → O(K²)로 메모리 사용량 대폭 감소
- 특히 자물쇠가 클 때 효과적

### 4. **논리적 명확성**

- 각 단계의 의미가 명확
- 디버깅 시 어느 부분에서 실패했는지 쉽게 파악

이 풀이는 **"문제의 본질을 수학적으로 재정의"**하고 **"불필요한 계산을 제거"**한 매우 우아한 솔루션이다! 🎯
